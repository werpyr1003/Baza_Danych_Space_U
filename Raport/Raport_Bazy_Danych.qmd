---
title: "Analiza działalności firmy Space-U"
author:
- Weronika Jaszkiewicz
- Dominik Hołoś
- Weronika Pyrtak
- Katarzyna Rudzińska
subtitle: Bazy Danych
output:
  html_document:
    toc: true
    df_print: paged
  pdf_document:
    extra_dependencies: ["multirow"]
    latex_engine: xelatex
    toc: true
    fig_caption: true
    fig_width: 5
    fig_height: 4
    number_sections: false
    header-includes:
      - \usepackage{polyglossia}
      - \setmainlanguage{polish}
      - \usepackage{graphicx}
      - \usepackage{float}
fontsize: 12pt
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

```{r, echo = FALSE, warning=FALSE, message = FALSE}
if (!require(RMariaDB)) install.packages("RMariaDB")
if (!require(DBI)) install.packages("DBI")
if (!require(RMySQL)) install.packages("RMySQL")
if (!require(dplyr)) install.packages("dplyr")
if (!require(ggplot2)) install.packages("ggplot2")
if (!require(tidyr)) install.packages("tidyr")
if (!require(lubridate)) install.packages("lubridate")
if (!require(RColorBrewer)) install.packages("RColorBrewer")
if (!require(kableExtra)) install.packages("kableExtra")
```

```{r, echo=FALSE}
con <- dbConnect(MariaDB(),
                 user = "team08",
                 password = "te@mlob",
                 dbname = "team08",
                 host = "giniewicz.it",
                 port = 3306)
```

# Wstęp o firmie

```{r, echo = FALSE}
# Liczba aktywnych pracowników
employee_count <- dbGetQuery(con, "
  SELECT COUNT(DISTINCT e.employee_id) AS n 
  FROM employee e
  WHERE fire_date IS NULL
")$n

# Lista unikalnych stanowisk
positions <- dbGetQuery(con, "SELECT DISTINCT position FROM employee
WHERE fire_date IS NULL")$position
positions_text <- paste(positions, collapse = ", ")

# Liczba klientów (w ciągu ostatniego roku)
client_count <- dbGetQuery(con, "
  SELECT COUNT(DISTINCT client_id) AS n
  FROM booking
")$n

# Liczba rakiet
rocket_count <- dbGetQuery(con, "
  SELECT COUNT(*) AS n FROM rocket
")$n

# Liczba typów wycieczek
triptype_count <- dbGetQuery(con, "
  SELECT COUNT(*) AS n FROM trip_type
")$n

# Liczba galaktyk
galaxy_count <- dbGetQuery(con, "
  SELECT COUNT(*) AS n FROM galaxy
")$n

# Liczba systemów planet
planetary_system_count <- dbGetQuery(con, "
  SELECT COUNT(*) AS n FROM planetary_system
")$n
```

Firma Space-U jest firmą turystyczną organizującą wyprawy kosmiczne,
oferującą doświadczenie podróży między galaktycznych. Firma zatrudnia
`r employee_count` pracowników na stanowiskach `r positions_text` i do
tej pory obsłużyła `r client_count` klientów. Do dyspozycji firmy jest
`r rocket_count` rakiet. Firma oferuje `r triptype_count` typów wypraw. Firma
operuje w `r galaxy_count` galaktykach, w tym w
`r planetary_system_count` systemach planetarnych

# Zawartość raportu

Celem raportu było przeanalizowanie działalności firmy Space-U pod kątem
rentowności wypraw, struktury kosztów, lojalności klientów, sezonowości
oraz efektywności operacyjnej w różnych galaktykach i systemach
planetarnych. Zadano następujące pytania analityczne:

1.  Jakie wyprawy są najbardziej popularne i opłacalne?

2.  Czy firma rośnie, czy traci klientów?

3.  Jakie czynniki wpływają na powracalność klientów?

4.  Czy wyprawy round-trip są bardziej popularne w określonych
    miejscach?

5.  Czy pojemność rakiet wpływa na punktualność?

6.  Jak wynagrodzenia pracowników wiążą się z wyprawami?

7.  Które galaktyki i układy są najbardziej dochodowe?

8.  Czy odległość od Ziemi wpływa na organizację wypraw?

9.  Jakie są trendy sezonowe w działalności firmy?

# Najpopularniejsze wyprawy - koszty, przychody i opłacalność

```{r, echo= FALSE}
# Najpopularniejsze rodzaje wypraw - liczba rezerwacji
query_popularity <- "
SELECT
    tt.trip_type_id,
    tt.name AS trip_name,
    COUNT(b.booking_id) AS bookings_count
FROM booking b
JOIN trip t ON b.trip_id = t.trip_id
JOIN trip_type tt ON t.trip_type_id = tt.trip_type_id
GROUP BY tt.trip_type_id, tt.name
ORDER BY bookings_count DESC
"
popularity <- dbGetQuery(con, query_popularity)
top_5_names <- paste(popularity$trip_name[1:5], collapse = ", ")

top_5_counts <- popularity$bookings_count[1:5]
min_booking <- min(top_5_counts)
max_booking <- max(top_5_counts)
```

```{r, echo = FALSE}
# Koszty dla każdego rodzaju wyprawy
query_costs <- "
SELECT
    tt.trip_type_id,
    SUM(c.amount) AS total_costs
FROM cost c
JOIN trip t ON c.trip_id = t.trip_id
JOIN trip_type tt ON t.trip_type_id = tt.trip_type_id
GROUP BY tt.trip_type_id
"
costs <- dbGetQuery(con, query_costs)
```

```{r, echo = FALSE}
# Przychody dla każdego rodzaju wyprawy
query_revenue <- "
SELECT
    tt.trip_type_id,
    SUM(tr.amount) AS total_revenue
FROM transaction tr
JOIN trip t ON tr.trip_id = t.trip_id
JOIN trip_type tt ON t.trip_type_id = tt.trip_type_id
GROUP BY tt.trip_type_id
"
revenue <- dbGetQuery(con, query_revenue)
```

```{r, echo = FALSE}
analysis_data <- popularity %>%
  left_join(costs, by = "trip_type_id") %>%
  left_join(revenue, by = "trip_type_id") %>%
  group_by(trip_type_id) %>%
  mutate(
    total_costs = ifelse(is.na(total_costs), 0, total_costs),
    total_revenue = ifelse(is.na(total_revenue), 0, total_revenue),
    profit = total_revenue - total_costs,
    profit_margin = ifelse(total_revenue > 0, profit / total_revenue, 0)
  ) %>%
  arrange(desc(bookings_count))

top_profit <- analysis_data[1:5, ]

```

```{r, echo = FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(scales)

analysis_data %>%
  select(trip_name, bookings_count, total_costs, total_revenue, profit, profit_margin) %>%
  kable(
    caption = "Tabela 1. Zestawienie popularności, kosztów i zysków według rodzaju podróży",
    format = "html",
    digits = 2
  ) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

```

Tabela 1. przedstawia zestawienie danych dotyczących różnych typów podróży kosmicznych. Każdy wiersz odnosi się do konkretnego rodzaju podróży (*trip_name*). Kolumna *bookings_count* zawiera liczbę dokonanych rezerwacji, *total_costs* to całkowite koszty realizacji danego typu podróży, natomiast *total_revenue* przedstawia łączny przychód. Na tej podstawie wyliczono *profit* (czyli zysk netto: przychód minus koszty) oraz *profit_margin* – marżę zysku, wyrażoną jako udział zysku w przychodzie.

```{r, echo = FALSE}
ggplot(analysis_data, aes(x = reorder(trip_type_id, bookings_count), y = bookings_count)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  scale_x_discrete(labels = setNames(analysis_data$trip_name, analysis_data$trip_type_id)) +
  labs(
    title = "Liczba rezerwacji na rodzaje wypraw",
    x = "Rodzaj wyprawy",
    y = "Liczba rezerwacji"
  ) +
  theme_minimal()
```

Analiza danych rezerwacyjnych wskazuje, że największą popularnością
wśród klientów cieszyły się wyprawy typu `r top_5_names`. Każda z nich
miała od `r min_booking` do `r max_booking` rezerwacji, co potwierdza
ich wysokie zainteresowanie na tle pozostałych ofert.

```{r, echo = FALSE}
ggplot(analysis_data, aes(x = reorder(trip_type_id, profit), y = profit)) +
  geom_bar(stat = "identity", fill = "darkgreen") +
  coord_flip() +
  scale_x_discrete(labels = setNames(analysis_data$trip_name, analysis_data$trip_type_id)) +
  labs(title = "Zysk brutto dla rodzajów wypraw", x = "Rodzaj wyprawy", y = "Zysk") +
  theme_minimal()
```

Pod względem rentowności na czoło wysuwają się wyprawy:\
- `r analysis_data$trip_name[1]` :
`r formatC(analysis_data$profit[1] / 1e6, format = "f", digits = 2)` mln USD zysku brutto\
- `r analysis_data$trip_name[2]` :
`r formatC(analysis_data$profit[2] / 1e6, format = "f", digits = 2)` mln USD
zysku brutto\
- `r analysis_data$trip_name[3]` :
`r formatC(analysis_data$profit[3] / 1e6, format = "f", digits = 2)` mln USD
zysku brutto\
- `r analysis_data$trip_name[4]` :
`r formatC(analysis_data$profit[4] / 1e6, format = "f", digits = 2)` mln USD
zysku brutto\
- `r analysis_data$trip_name[5]` :
`r formatC(analysis_data$profit[5] / 1e6, format = "f", digits = 2)` mln USD
zysku brutto

To pokazuje, że nie tylko popularność wpływa na opłacalność – ważna jest
również struktura kosztów i cena jednostkowa. Co ciekawe, wiele wypraw z
mniejszą liczbą rezerwacji
(np.`r sum(analysis_data$bookings_count < mean(analysis_data$bookings_count))` z
`r nrow(analysis_data)`) okazało się bardziej zyskownych niż te najbardziej
uczęszczane.

Z drugiej strony, odnotowano kilka wypraw generujących straty –
np.`r paste(analysis_data %>% filter(profit < 0) %>% arrange(profit) %>% head(2) %>% pull(trip_name), collapse = " i ")`
– ich koszty przewyższyły uzyskane przychody, a wskaźnik powrotu
klientów po tych wyjazdach był zerowy. Wskazuje to jednoznacznie na
potrzebę rewizji tych pozycji w ofercie.

Opłacalność wypraw zależy nie tylko od liczby klientów, ale przede
wszystkim od właściwego zarządzania kosztami i odpowiedniego ustalenia
cen. Warto skupić się na dalszym rozwijaniu wypraw o wysokiej
rentowności i ograniczyć te, które przynoszą straty.

# Dynamika zmian liczby klientów w czasie

```{r, echo = FALSE}
trip_data <- dbGetQuery(con, "
SELECT 
  t.trip_id,
  t.trip_type_id,
  tt.name AS trip_type,
  tt.is_round_trip,
  tt.planet_id,
  p.planet,
  c.amount AS cost_amount,
  tr.amount AS transaction_amount
FROM trip t
JOIN trip_type tt ON t.trip_type_id = tt.trip_type_id
JOIN planet p ON tt.planet_id = p.planet_id
LEFT JOIN cost c ON t.trip_id = c.trip_id
LEFT JOIN transaction tr ON t.trip_id = tr.trip_id
")

# Agregacja: suma przychodów, kosztów i liczba wypraw dla każdego typu
summary_df <- trip_data %>%
  group_by(trip_type, planet) %>%
  summarise(
    trip_type_id = first(trip_type_id),
    total_income = sum(transaction_amount, na.rm = TRUE),
    total_cost = sum(cost_amount, na.rm = TRUE),
    count = n(),
    profit = total_income - total_cost,
    avg_profit_per_trip = (total_income - total_cost) / n()
  ) %>%
  arrange(desc(count))
```

```{r, echo = FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(scales)

summary_df%>%
  select(trip_type_id, total_income, total_cost, count, profit, avg_profit_per_trip) %>%
  kable(
    caption = "Tabela 2. Suma przychodów, kosztów i liczba wypraw dla każdego typu wycieczki",
    format = "html",
    digits = 2
  ) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))
```
Tabela 2. przedstawia zestawienie finansowe dla różnych typów wycieczek kosmicznych, oznaczonych identyfikatorem *trip_type_id*. Kolumny *total_income* oraz *total_cost* przedstawiają łączne wartości przychodów i kosztów wygenerowanych przez każdy typ wycieczki. W kolumnie *count* znajduje się liczba zrealizowanych wypraw danego rodzaju. Na tej podstawie wyliczono wartość *profit* (czyli całkowity zysk) oraz *avg_profit_per_trip* — średni zysk przypadający na jedną wyprawę.

Zestawienie pokazuje łączny przychód, koszty i zyski brutto dla
poszczególnych typów wypraw. Najwięcej wypraw przeprowadzono na planetę `r summary_df$planet[1]` (`r summary_df$count[1]` wypraw), a
najmniej w przypadku planety `r summary_df$planet[nrow(summary_df)]`
(`r summary_df$count[nrow(summary_df)]` wypraw).

```{r, echo = FALSE}
ggplot(summary_df, aes(x = reorder(trip_type_id, avg_profit_per_trip), y = avg_profit_per_trip / 1e6, fill = planet)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  scale_x_discrete(labels = setNames(summary_df$trip_type, summary_df$trip_type_id)) +
  scale_y_continuous(labels = comma) +
  labs(
    title = "Średni zysk na podróż wg typu wyprawy",
    x = "Typ wyprawy",
    y = "Średni zysk [mln USD]"
  ) +
  theme_minimal()


summary_df_sorted <- summary_df[order(-summary_df$avg_profit_per_trip), ]
top_5_types <- paste(summary_df_sorted$trip_type[1:5], collapse = ", ") 
last_3_types <- paste(tail(summary_df_sorted$trip_type, 3), collapse = ", ")
```

Wykres pokazuje średni zysk brutto przypadający na pojedynczą wyprawę
dla każdego typu misji. Na jego podstawie widać, że wyprawy typu
`r top_5_types` są pięcioma najbardziej dochodowymi. Z kolei wyprawy, które generują
najniższy średni zysk (lub nawet straty), to
`r last_3_types`.
Wskazuje to, że warto dokładnie przeanalizować ich opłacalność i
ewentualnie rozważyć modyfikację oferty.

```{r, echo = FALSE}
query <- "
SELECT
    DATE_FORMAT(t.departure_date, '%Y-%m') AS month,
    COUNT(DISTINCT b.client_id) AS unique_clients
FROM booking b
JOIN trip t ON b.trip_id = t.trip_id
GROUP BY month
ORDER BY month;
"

# Pobranie danych
monthly_clients <- dbGetQuery(con, query)

# Konwersja kolumny month na datę (1-szy dzień miesiąca)
monthly_clients$month <- as.Date(paste0(monthly_clients$month, "-01"))

# Wykres liniowy
ggplot(monthly_clients, aes(x = month, y = unique_clients)) +
  geom_line(size = 1.2, color = "blue") +
  geom_point(size = 3, color = "red") +
  labs(
    title = "Liczba obsłużonych klientów w każdym miesiącu",
    x = "Miesiąc",
    y = "Liczba unikalnych klientów"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%Y-%m"
  )
```

Analiza miesięczna pokazuje, jak zmieniała się liczba obsłużonych
klientów na przestrzeni czasu. Największy ruch zanotowano w
`r format(monthly_clients$month[which.max(monthly_clients$unique_clients)], "%B %Y")`,
obsługując wtedy `r max(monthly_clients$unique_clients)` unikalnych
klientów. Z kolei najmniej klientów firma miała w
`r format(monthly_clients$month[which.min(monthly_clients$unique_clients)], "%B %Y")`,
tylko `r min(monthly_clients$unique_clients)` osób.

Można zauważyć, że najchętniej wybieranym sezonem na wyprawy jest okres
zimowo-wiosenny. Zmienność w liczbie klientów sugeruje potrzebę
elastycznego zarządzania zasobami i wdrożenia sezonowych strategii
cenowych.

# Powracalność klientów
```{r, echo = FALSE}
query <- "
SELECT b.booking_id, b.client_id, b.trip_id, t.trip_type_id, tt.name AS trip_name
FROM booking b
JOIN trip t ON b.trip_id = t.trip_id
JOIN trip_type tt ON t.trip_type_id = tt.trip_type_id
ORDER BY b.client_id, b.booking_id
"
bookings <- dbGetQuery(con, query)

# Dodanie numeru kolejnej rezerwacji dla każdego klienta
bookings <- bookings %>%
  group_by(client_id) %>%
  arrange(booking_id) %>%
  mutate(trip_order = row_number()) %>%
  ungroup()

# Maksymalna liczba rezerwacji dla każdego klienta
max_trips <- bookings %>%
  group_by(client_id) %>%
  summarise(max_trip_order = max(trip_order))

# Połączenie, by wiedzieć, ile razy klient rezerwował
bookings <- bookings %>%
  left_join(max_trips, by = "client_id")

# Zaznaczamy, czy klient wrócił po danej wycieczce
bookings <- bookings %>%
  mutate(returned = max_trip_order > trip_order)

# Analiza retencji
retention_summary <- bookings %>%
  group_by(trip_id, trip_name) %>%
  summarise(
    total_clients = n_distinct(client_id),
    returned_clients = sum(returned)
  ) %>%
  mutate(return_rate = round(returned_clients / total_clients, 2)) %>%
  arrange(desc(return_rate))
```

```{r, echo = FALSE}
ggplot(retention_summary, aes(x = reorder(trip_name, return_rate), y = return_rate, fill = return_rate)) +
  geom_col() +
  coord_flip() +
  scale_fill_viridis_c() +
  labs(title = "Wskaźnik powrotu klientów po wycieczkach",
       x = "Nazwa wycieczki",
       y = "Wskaźnik powrotu (0-1)") +
  theme_minimal()

max_return_rate <- round(max(retention_summary$return_rate, na.rm = TRUE) * 0.9, 2)


high_return_trips <- retention_summary %>% 
  filter(return_rate > max_return_rate) %>% 
  pull(trip_name) %>% 
  paste(collapse = ", ")

low_return_trips <- retention_summary %>% 
  filter(return_rate < 0.3) %>% 
  pull(trip_name) %>% 
  paste(collapse = ", ")

low_return_trips <- if (length(low_return_trips) == 0) {
  "BRAK"
} else {
  paste(low_return_trips, collapse = ", ")
}
```

Na wykresie widać, które wycieczki budują lojalność klientów. Najlepiej
wypadły:
`r high_return_trips`, powyżej `r max_return_rate`.
Wysoka lojalność może wskazywać na unikalne doświadczenia, wysoki poziom
satysfakcji lub atrakcyjną cenę. Warto zwrócić uwagę na wyprawy z niskim
wskaźnikiem powrotu – poniżej 0.3 – takie jak
`r low_return_trips`, które wymagają
dalszej analizy i ewentualnego dostosowania oferty.

Lojalność klientów powinna być kluczowym wskaźnikiem sukcesu wypraw –
warto ją monitorować i budować programy retencji oparte na danych.

# Porównanie wycieczek w jedną stronę z wycieczkami "tam i z powrotem"

Współczynnik round-trip ratio określa stosunek liczby podróży tam i z powrotem do liczby wypraw w jedną stronę. Jest liczony jako:

$$
\mathrm{round\_trip\_ratio} = \frac{\mathrm{round\_trip}}{\mathrm{one\_way} + 1}
$$

Użycie +1 w mianowniku zapobiega dzieleniu przez zero w przypadku braku podróży one-way.

```{r, echo = FALSE}
query <- "
SELECT
  p.planet AS planet_name,
  p.planet_id AS planet,
  tt.is_round_trip,
  COUNT(t.trip_id) AS trip_count,
  GROUP_CONCAT(sf.feature, ', ') AS special_features,
  p.orbit_period_days,
  p.day0_x_coord,
  p.day0_y_coord,
  p.day0_z_coord
FROM trip t
JOIN trip_type tt ON t.trip_type_id = tt.trip_type_id
JOIN planet p ON tt.planet_id = p.planet_id
LEFT JOIN planet_feature pf ON p.planet_id = pf.planet_id
LEFT JOIN special_feature sf ON pf.feature_id = sf.feature_id
GROUP BY 
  p.planet_id, tt.is_round_trip, 
  p.orbit_period_days, 
  p.day0_x_coord, p.day0_y_coord, p.day0_z_coord
"

df <- dbGetQuery(con, query)

# Oddzielenie round-trip i one-way
df_wide <- df %>%
  pivot_wider(names_from = is_round_trip, values_from = trip_count, values_fill = 0) %>%
  rename(one_way = `0`, round_trip = `1`) %>%
  mutate(
    round_trip_ratio = round_trip / (one_way + 1),  
    total_visits = round_trip + one_way,
    category = case_when(
      round_trip_ratio > 2 ~ "dominują round-trip",
      round_trip_ratio < 0.5 ~ "dominują one-way",
      TRUE ~ "zrównoważone"
    ),
    x = day0_x_coord,
    y = day0_y_coord,
    z = day0_z_coord
  )
planets_ratio <- df_wide %>% arrange(desc(round_trip_ratio)) 

max_ratio <- max(df_wide$round_trip_ratio, na.rm = TRUE)
top_planets <- df_wide %>%
  filter(round_trip_ratio == max_ratio)

ggplot(df_wide, aes(x = reorder(planet, round_trip_ratio), y = round_trip_ratio)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  scale_x_discrete(labels = setNames(df_wide$planet_name, df_wide$planet)) +
  labs(
    title = "Stosunek round-trip do one-way dla planet",
    x = "Planeta",
    y = "Round-trip ratio"
  ) +
  theme_minimal()

```

Największy udział round-tripów odnotowano dla planety
`r top_planets$planet_name`, gdzie współczynnik wyniósł
`r unique(round(top_planets$round_trip_ratio, 2))`. Świadczy to o ich
atrakcyjności lub logistyce sprzyjającej podróżom powrotnym.

```{r, echo = FALSE}
# Rozdziel cechy specjalne do osobnych wierszy
df_expanded <- df_wide %>%
  separate_rows(special_features, sep = ",\\s*")%>%
  filter(!is.na(special_features), special_features != "")

# Wykres poprawiony: Boxplot dla pojedynczych cech
ggplot(df_expanded, aes(x = reorder(special_features, round_trip_ratio, median), y = round_trip_ratio)) +
  geom_boxplot(fill = "darkseagreen3") +
  coord_flip() +
  labs(title = "Round-trip ratio wg cech specjalnych", x = "Cechy specjalne", y = "Round-trip ratio") +
  theme_minimal()

top_features <- df_expanded %>%
  group_by(special_features) %>%
  summarise(med = median(round_trip_ratio, na.rm = TRUE), .groups = "drop") %>%
  filter(med == max(med, na.rm = TRUE)) %>%
  pull(special_features)

```

Cechy specjalne mają wpływ na preferencje dotyczące typu wypraw.
Najwyższą medianę współczynnika round-trip zaobserwowano dla cechy `r paste(top_features, collapse = ", ")`. Sugeruje to, że planety zawierające tą cechę są atrakcyjne do wizyt powrotnych – być może ze względu na warunki sprzyjające krótkim, rekreacyjnym wyprawom.


```{r, echo = FALSE}
ggplot(df_wide, aes(x = orbit_period_days, y = round_trip_ratio)) +
  geom_point(color = "tomato", alpha = 0.7, size = 3) +
  geom_smooth(method = "lm", se = FALSE, color = "black", linetype = "dashed") +
  labs(title = "Round-trip ratio a okres orbitalny planety", x = "Okres orbitalny (dni)", y = "Round-trip ratio") +
  theme_minimal()
```

Widoczna jest
`r ifelse(cor(df_wide$orbit_period_days, df_wide$round_trip_ratio, use = "complete.obs") > 0, "dodatnia", "ujemna")`
korelacja
(`r round(cor(df_wide$orbit_period_days, df_wide$round_trip_ratio, use = "complete.obs"), 2)`)
między długością orbity a skłonnością do wypraw typu round-trip,co
oznacza, że dalsze planety rzadziej odwiedzane są z powrotem.

```{r, echo = FALSE}
ggplot(df_wide, aes(x = x, y = y, color = category)) +
  geom_point(size = 4, alpha = 0.8) +
  labs(title = "Układ planet wg pozycji (X/Y)", x = "X", y = "Y") +
  theme_minimal()
```

Analiza wykazała, że planety z najwyższym współczynnikiem round-trip to
m.in. `r paste(head(top_planets$planet_name, 5), collapse = ", ")`, z
maksymalnym wskaźnikiem `r round(top_planets$round_trip_ratio[1], 2)`.
W przestrzeni najwięcej planet to te z
`r df_wide %>% filter(category == "dominują round-trip") %>% nrow()`
dominującymi round-trip,
`r df_wide %>% filter(category == "dominują one-way") %>% nrow()`
dominującymi one-way i
`r df_wide %>% filter(category == "zrównoważone") %>% nrow()`
zrównoważonymi wyprawami. Oznacza to, że różnorodność preferencji podróżnych jest wyraźnie widoczna i może wskazywać na zróżnicowane potrzeby oraz charakterystyki poszczególnych planet.

Wnioski te mogą być wykorzystane przy planowaniu nowych kierunków i
tworzeniu elastycznych modeli podróży (np. mix one-way + return).

# Wpływ pojemności rakiety na czynniki podróży

```{r, echo = FALSE}
query <- "
SELECT
  c.client_id,
  c.first_name,
  c.last_name,
  r.rocket_id,
  r.name AS rocket_name,
  r.capacity,
  t.trip_id,
  t.departure_date,
  t.return_date,
  t.status
FROM client c
JOIN booking b ON c.client_id = b.client_id
JOIN trip t ON b.trip_id = t.trip_id
JOIN rocket r ON t.rocket_id = r.rocket_id
"

df_all <- dbGetQuery(con, query)
```

```{r, echo = FALSE}
stats_per_capacity <- df_all %>%
  group_by(capacity) %>%
  summarise(
    total_clients = n(),             # liczba wszystkich klientów (wystąpień)
    total_flights = n_distinct(trip_id),
    delayed_flights = n_distinct(trip_id[status == "Delayed"]),,
    .groups = "drop"
  ) %>%
  arrange(desc(capacity))
```

```{r, echo = FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
library(scales)

stats_per_capacity%>%
  select(capacity, total_clients,total_flights, delayed_flights,  ) %>%
  kable(
    caption = "Tabela 3. Dane dotyczące rakiet względem ich pojemności",
    format = "html",
    digits = 2
  ) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))
```
Tabela 3. prezentuje statystyki dotyczące rakiet w zależności od ich pojemności (*capacity*). W kolumnie *total_clients* podano łączną liczbę obsłużonych pasażerów, *total_flights* wskazuje liczbę zrealizowanych lotów, natomiast *delayed_flights* zawiera liczbę lotów, które wystąpiły z opóźnieniem. Dane pozwalają na ocenę efektywności i niezawodności rakiet o różnej pojemności.

Największą liczbę klientów przewieziono rakietami o pojemności `r stats_per_capacity %>% filter(total_clients == max(total_clients)) %>% pull(capacity)`, łączna liczba obsłużonych pasażerów wyniosła aż `r max(stats_per_capacity$total_clients)`. Jeśli chodzi o liczbę odbytych lotów, przodowały rakiety o pojemności `r stats_per_capacity %>% filter(total_flights == max(total_flights)) %>% pull(capacity)`, wykonując `r max(stats_per_capacity$total_flights)` wypraw.

```{r, echo = FALSE}
flights_per_client_capacity <- df_all %>%
  group_by(capacity, client_id, first_name, last_name) %>%
  summarise(number_of_flights = n_distinct(trip_id), .groups = "drop")

# Wykres: Średnia liczba lotów na klienta w zależności od pojemności
avg_flights_per_client <- flights_per_client_capacity %>%
  group_by(capacity) %>%
  summarise(avg_flights = mean(number_of_flights), .groups = "drop")

ggplot(avg_flights_per_client, aes(x = factor(capacity), y = avg_flights, fill = factor(capacity))) +
  geom_col() +
  labs(title = "Średnia liczba lotów na klienta wg pojemności rakiety",
       x = "Pojemność rakiety",
       y = "Średnia liczba lotów na klienta") +
  theme_minimal() -> plot_avg_flights

print(plot_avg_flights)
```

Pod względem średniej liczby podróży przypadającej na jednego klienta, najwyższy wynik zanotowano dla pojemności `r avg_flights_per_client %>% filter(avg_flights == max(avg_flights)) %>% pull(capacity)`. W tym przypadku, przeciętny klient korzystał z usług rakiety średnio `r round(max(avg_flights_per_client$avg_flights), 2)` razy. Może to świadczyć o preferencjach bardziej zaangażowanych lub lojalnych klientów.


```{r, echo = FALSE}
stats_per_capacity <- stats_per_capacity %>%
  mutate(delay_ratio = delayed_flights / total_flights)

ggplot(stats_per_capacity, aes(x = factor(capacity), y = delay_ratio, fill = factor(capacity))) +
  geom_col() +
  scale_fill_brewer(palette = "Pastel1") +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  labs(title = "Procent opóźnionych lotów według pojemności rakiety",
       x = "Pojemność rakiety",
       y = "Procent opóźnionych lotów") +
  theme_minimal() -> plot_delay_ratio

print(plot_delay_ratio)
```

```{r, echo = FALSE}
min_rows <- stats_per_capacity %>%
  filter(delay_ratio == min(delay_ratio)) %>%
  select(capacity, delay_ratio)

max_rows <- stats_per_capacity %>%
  filter(delay_ratio == max(delay_ratio)) %>%
  select(capacity, delay_ratio)


min_capacities <- min_rows$capacity
min_delay_ratios <- min_rows$delay_ratio

max_capacities <- max_rows$capacity
max_delay_ratios <- max_rows$delay_ratio
```
Z kolei w zestawieniu częstości opóźnień widać wyraźne różnice. Najniższy odsetek opóźnionych lotów dotyczył rakiet o pojemności `r min_capacities`, wynosząc `r scales::percent(unique(min_delay_ratios, accuracy = 1))`. Największy odsetek opóźnień przypadł na rakiety o pojemności `r max_capacities`, gdzie opóźnienia osiągnęły aż `r scales::percent(max_delay_ratios, accuracy = 1)`.
  

```{r, echo = FALSE}
# --- 3. Wykres: Liczba unikalnych klientów per pojemność ---
ggplot(stats_per_capacity, aes(x = factor(capacity), y = total_clients, fill = factor(capacity))) +
  geom_col() +
  labs(title = "Liczba klientów (wystąpień) według pojemności rakiety",
       x = "Pojemność rakiety",
       y = "Liczba klientów") +
  theme_minimal() -> plot_clients

print(plot_clients)
```
Liczba klientów w zależności od pojemności pokazuje wyraźną tendencję: rakiety o większej pojemności obsługują więcej pasażerów. Największą popularnością cieszyły się maszyny o pojemności `r stats_per_capacity %>% filter(total_clients == max(total_clients)) %>% pull(capacity)`, które przewiozły łącznie `r stats_per_capacity %>% filter(total_clients == max(total_clients)) %>% pull(total_clients)` klientów. Mniejsze rakiety naturalnie miały mniejsze obłożenie, co jednak może być również efektem ich rzadszego wykorzystania w harmonogramie lotów.

# Analiza wynagrodzenia pracowników względem uczęszczanych wypraw

```{r, echo = FALSE}

query <- "
SELECT
  e.employee_id,
  e.first_name,
  e.last_name,
  e.salary,
  e.position,
  te.role_in_trip,
  t.trip_id,
  t.status
FROM trip_employee te
JOIN employee e ON te.employee_id = e.employee_id
JOIN trip t ON te.trip_id = t.trip_id
"

df <- dbGetQuery(con, query)
```

```{r, echo = FALSE}
# Liczba wypraw przypisanych do każdego pracownika z wynagrodzeniem i rolami
employee_trip_counts <- df %>%
  group_by(employee_id, first_name, last_name, salary) %>%
  summarise(
    total_trips = n_distinct(trip_id),
    roles = paste(unique(role_in_trip), collapse = ", "),
    .groups = "drop"
  ) %>%
  arrange(desc(total_trips))
```

```{r, echo = FALSE}
# Liczba wystąpień każdej roli w wyprawach 
role_counts <- df %>%
  group_by(role_in_trip) %>%
  summarise(count = n(), .groups = "drop")

ggplot(role_counts, aes(x = role_in_trip, y = count, fill = role_in_trip)) +
  geom_col(show.legend = FALSE) +
  labs(title = "Liczba wystąpień poszczególnych ról w wyprawach",
       x = "Rola w wyprawie",
       y = "Liczba wystąpień") +
  theme_minimal() +
  coord_flip()
```

```{r, echo = FALSE}
max_rows <- role_counts %>%
  filter(count == max(count)) %>%
  select(role_in_trip, count)

max_role<- max_rows$role_in_trip
max_count <- max_rows$count
```

Analiza liczby wystąpień ról pokazuje, które funkcje są kluczowe i
najczęściej powtarzane. Wykres słupkowy pomaga zidentyfikować, że
dominujące role to `r max_role`. Oznacza to, że są to funkcje kluczowe
operacyjnie, silnie związane z liczbą realizowanych wypraw.

```{r, echo = FALSE}
# Top 10 pracowników wg liczby wypraw i ich pensje
top_employees <- df %>%
  group_by(employee_id, first_name, last_name, role_in_trip, salary, position) %>%
  summarise(trips = n_distinct(trip_id), .groups = "drop") %>%
  arrange(desc(salary)) %>%
  head(10)

ggplot(top_employees, aes(x = reorder(paste(first_name, last_name), salary), y = salary, fill = role_in_trip)) +
  geom_col() +
  labs(
    title = "Top 10 pracowników wg liczby wypraw i ich wynagrodzenia",
    x = "Pracownik",
    y = "Wynagrodzenie",
    fill = "Rola"
  ) +
  coord_flip() +
  theme_minimal()

top_3_employees <- top_employees %>% head(3)
top_3_employees_names <- paste(top_3_employees$first_name, top_3_employees$last_name, collapse = ", ")

min_salary_rounded <- min(top_3_employees$salary)
max_salary_rounded <- max(top_3_employees$salary)

top3_role_in_trip <- unique(top_3_employees$role_in_trip)

```

Analizując wykres pokazujący zarobki pracowników, w top 3 najlepiej zarabiającymi pracownikami są `r paste(top_3_employees_names, collapse = ", ")`, którzy zarabiają między `r scales::comma(min_salary_rounded)` a `r scales::comma(max_salary_rounded)` USD. Zajmują oni stanowiska `r paste(top3_role_in_trip, collapse = ", ")`.


```{r, echo = FALSE}
#  Liczba wypraw z podziałem na role i status wyprawy
role_status_counts <- df %>%
  group_by(role_in_trip, status) %>%
  summarise(count = n_distinct(trip_id), .groups = "drop")

# Powiązanie aktywności z wynagrodzeniem
employee_summary <- df %>%
  group_by(employee_id, first_name, last_name, salary, position) %>%
  summarise(
    total_trips = n_distinct(trip_id),
    roles = paste(unique(role_in_trip), collapse = ", "),
    .groups = "drop"
  ) %>%
  arrange(desc(total_trips))

ggplot(employee_summary, aes(x = total_trips, y = salary)) +
  geom_point(aes(color = position), size = 3, alpha = 0.7) +
  geom_smooth(method = "lm", se = FALSE, color = "darkblue") +
  labs(
    title = "Związek między liczbą wypraw a wynagrodzeniem pracowników",
    x = "Liczba wypraw",
    y = "Wynagrodzenie",
    color = "Stanowisko"
  ) +
  theme_minimal()
```

Porównując wykresy dotyczące liczby wypraw per rola oraz poziomu
zarobków, widać
`r ifelse(cor(employee_summary$total_trips, employee_summary$salary, use = "complete.obs") > 0, "dodatnia", "ujemna")`
korelacja
(`r round(cor(employee_summary$total_trips, employee_summary$salary, use = "complete.obs"), 2)`)
między zaangażowaniem w wyprawy a poziomem wynagrodzenia. Oznacza to, że
funkcje częściej wykorzystywane w misjach są także lepiej opłacane.
Wskazuje to na dobrze dostosowaną strukturę płac do potrzeb
operacyjnych.


# Wpływ lokalizacji planet na zyskowność wypraw oraz związek między odległością od Ziemi a ich częstotliwością

```{r, echo = FALSE}
query <- "
WITH planet_distances AS (
  SELECT
    ps.system AS planetary_system,
    ps.system_id AS planetary_system_id,
    SQRT(POWER(p.day0_x_coord, 2) + POWER(p.day0_y_coord, 2) + POWER(p.day0_z_coord, 2)) AS planet_distance
  FROM planet p
  JOIN planetary_system ps ON p.system_id = ps.system_id
)
SELECT
  g.galaxy AS galaxy_name,
  ps.system AS planetary_system,
  ps.system_id AS planetary_system_id,
  COUNT(t.trip_id) AS num_trips,
  SUM(co.amount) AS total_cost,
  SUM(tr.amount) AS total_revenue,
  AVG(pd.planet_distance) AS avg_planet_distance
FROM trip t
JOIN trip_type tt ON t.trip_type_id = tt.trip_type_id
JOIN planet p ON tt.planet_id = p.planet_id
JOIN planetary_system ps ON p.system_id = ps.system_id
JOIN galaxy g ON ps.galaxy_id = g.galaxy_id
LEFT JOIN cost co ON t.trip_id = co.trip_id
LEFT JOIN transaction tr ON t.trip_id = tr.trip_id
JOIN planet_distances pd ON pd.planetary_system = ps.system
GROUP BY g.galaxy, ps.system, ps.system_id 

"

df_profit <- dbGetQuery(con, query)

df_profit <- df_profit %>%
  mutate(
    net_profit = total_revenue - total_cost,
    profit_per_trip = ifelse(num_trips > 0, net_profit / num_trips, NA)
  )
```

```{r, echo = FALSE}
# top 10 układów planetarnych wg zysku netto 
df_profit_sorted <- df_profit %>%
  arrange(desc(net_profit)) %>%
  head(10)

df_profit_sorted %>%
  mutate(
    total_revenue = comma(total_revenue),
    total_cost = comma(total_cost),
    net_profit = comma(net_profit),
    profit_per_trip = round(profit_per_trip, 2)
  ) %>%
  select(everything()) %>%
  kable(
    caption = "Tabela 4. Top 10 układów planetarnych wg zysku netto",
    format = "html"
  ) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))
```

Tabela 4. pokazuje 10 układów planetarnych generujących największy zysk
netto, co pozwala wskazać najbardziej dochodowe kierunki wypraw. Kolumny *galaxy_name* oraz *planetary_system* identyfikują lokalizację danej trasy. *num_trips* to liczba odbytych wypraw, *total_cost* i *total_revenue* przedstawiają odpowiednio całkowite koszty i przychody związane z realizacją tych tras. *avg_planet_distance* wskazuje średnią odległość do planet w danym układzie. Na podstawie przychodów i kosztów obliczono również *net_profit* (zysk netto) oraz *profit_per_trip*, czyli średni zysk przypadający na jedną wyprawę.

```{r, echo = FALSE}
galaxy_profit <- df_profit %>%
  group_by(galaxy_name) %>%
  summarise(total_net_profit = sum(net_profit), .groups = "drop") %>%
  arrange(desc(total_net_profit))

ggplot(galaxy_profit, aes(x = reorder(galaxy_name, total_net_profit), y = total_net_profit/1e6, fill = galaxy_name)) +
  geom_col(show.legend = FALSE) +
   scale_y_continuous(labels = comma) +
  labs(title = "Zysk netto według galaktyk",
       x = "Galaktyka",
       y = "Zysk netto [mln USD]") +
  theme_minimal() +
  coord_flip()
```

Wykres "Zysk netto według galaktyk" ilustruje znaczącą koncentrację
zysków w wybranych galaktykach. Galaktyka z najwyższym łącznym zyskiem
netto to
`r galaxy_profit %>% slice_max(total_net_profit) %>% pull(galaxy_name)`,
generująca łącznie
`r scales::comma(galaxy_profit %>% summarise(max(total_net_profit)) %>% pull())` USD.
Najmniej zyskowną galaktyką jest
`r galaxy_profit %>% slice_min(total_net_profit) %>% pull(galaxy_name)`
z łącznym zyskiem netto
`r scales::comma(galaxy_profit %>% summarise(min(total_net_profit)) %>% pull())` USD.

```{r, echo = FALSE}
top5_galaxies <- galaxy_profit %>%
  slice_max(order_by = total_net_profit, n = 5) %>%
  pull(galaxy_name)

df_top_sys <- df_profit %>%
  filter(galaxy_name %in% top5_galaxies)

ggplot(df_top_sys, aes(x = reorder(as.factor(planetary_system_id), net_profit), y = net_profit / 1e6, fill = galaxy_name)) +
  geom_col() +
  scale_y_continuous(labels = scales::comma) +
  scale_x_discrete(labels = setNames(df_top_sys$planetary_system, df_top_sys$planetary_system_id)) +
 labs(
    title = "Zysk netto wg układów planetarnych",
    x = "ID układu planetarnego",
    y = "Zysk netto [mln USD]",
    fill = "Galaktyka"
  ) +
  coord_flip() +
  theme_minimal()

```

W top 5 galaktykach widać wyraźne różnice w zyskowności między układami
planetarnymi. Można zauważyć, że w niektórych galaktykach pojedyncze
układy dominują pod względem generowanego zysku, co sugeruje
koncentrację atrakcyjnych celów wypraw.

```{r, echo = FALSE}
avg_profit_per_trip <- df_profit %>%
  group_by(galaxy_name) %>%
  summarise(avg_profit = mean(profit_per_trip, na.rm = TRUE), .groups = "drop")

ggplot(avg_profit_per_trip, aes(x = reorder(galaxy_name, avg_profit), y = avg_profit/1e6, fill = galaxy_name)) +
  geom_col(show.legend = FALSE) +
   scale_y_continuous(labels = comma) +
  labs(title = "Średni zysk na wyprawę wg galaktyk",
       x = "Galaktyka",
       y = "Średni zysk na wyprawę [mln USD]") +
  theme_minimal() +
  coord_flip()
```

Galaktyka o najwyższym średnim zysku na wyprawę to
`r avg_profit_per_trip %>% slice_max(avg_profit) %>% pull(galaxy_name)`,
ze średnim zyskiem około
`r scales::comma(avg_profit_per_trip %>% summarise(max(avg_profit)) %>% pull())` USD 
na wyprawę. To pokazuje, że efektywność pojedynczych wypraw różni się
znacznie między galaktykami.

```{r, echo = FALSE}
ggplot(df_profit, aes(x = avg_planet_distance, y = num_trips)) +
  geom_point(color = "steelblue", alpha = 0.6, size = 3) +
  geom_smooth(method = "lm", color = "darkred", se = FALSE) +
  labs(title = "Odległość planety a liczba wypraw",
       x = "Odległość planety od Ziemi (jedn. układowe)",
       y = "Liczba wypraw") +
  theme_minimal()
```

```{r, echo = FALSE}
cor_value <- cor(df_profit$avg_planet_distance, df_profit$num_trips, use = "complete.obs")
```

Analiza wykazuje, że korelacja między odległością planet a liczbą wypraw
wynosi `r round(cor_value, 3)`, co sugeruje
`r ifelse(abs(cor_value) < 0.3, "brak istotnej zależności", ifelse(cor_value > 0, "dodatnią zależność", "ujemną zależność"))`.
Oznacza to, że im dalej planeta od Ziemi, tym mniej wypraw jest do niej
organizowanych.

# Trendy sezonowe w liczbie wypraw, przychodach oraz ich statusach
```{r, echo = FALSE}
# Wczytanie danych z bazy danych
query <- "
SELECT
  t.trip_id,
  t.departure_date,
  t.status,
  tt.name AS trip_type,
  tr.amount
FROM trip t
JOIN trip_type tt ON t.trip_type_id = tt.trip_type_id
JOIN transaction tr ON t.trip_id = tr.trip_id
"

df <- dbGetQuery(con, query)

# Przetwarzanie danych
df <- df %>%
  mutate(
    departure_date = as.Date(departure_date),
    month_num = month(departure_date),
    quarter = quarter(departure_date)
  )

# Polskie pełne nazwy miesięcy
months_pl <- c("styczeń", "luty", "marzec", "kwiecień", "maj", "czerwiec", 
               "lipiec", "sierpień", "wrzesień", "październik", "listopad", "grudzień")

# Agregacja danych miesięcznych
monthly_summary <- df %>%
  group_by(month_num) %>%
  summarise(
    total_trips = n_distinct(trip_id),
    total_revenue = sum(amount, na.rm = TRUE),
    completed = sum(status == "Completed"),
    delayed = sum(status == "Delayed"),
    cancelled = sum(status == "Cancelled"),
    .groups = "drop"
  ) %>%
  mutate(month_name = months_pl[month_num]) %>%
  arrange(month_num)

# Agregacja danych kwartalnych
quarterly_summary <- df %>%
  group_by(quarter) %>%
  summarise(
    total_trips = n_distinct(trip_id),
    total_revenue = sum(amount, na.rm = TRUE),
    completed = sum(status == "Completed"),
    delayed = sum(status == "Delayed"),
    cancelled = sum(status == "Cancelled"),
    .groups = "drop"
  )
```

```{r, echo = FALSE}
# Wykres: liczba wypraw w poszczególnych miesiącach
ggplot(monthly_summary, aes(x = factor(month_name, levels = months_pl), y = total_trips, group = 1)) +
  geom_line(color = "steelblue", size = 1.2) +
  geom_point(color = "steelblue", size = 3) +
  labs(
    title = "Liczba wypraw w poszczególnych miesiącach",
    x = "Miesiąc",
    y = "Liczba wypraw"
  ) +
  theme_minimal() +
    theme(
    axis.text.x = element_text(angle = 45, hjust = 1)  # lepsza czytelność nazw miesięcy
  )
```

Największa liczba wypraw została zorganizowana w miesiącu 
`r monthly_summary$month_name[which.max(monthly_summary$total_trips)]`, 
osiągając `r scales::comma(max(monthly_summary$total_trips))` wypraw. 
Z kolei najmniejszą liczbę wypraw odnotowano w miesiącu 
`r monthly_summary$month_name[which.min(monthly_summary$total_trips)]`, 
z liczbą `r scales::comma(min(monthly_summary$total_trips))`. 
Różnice te sugerują istnienie wyraźnej sezonowości w liczbie organizowanych wypraw.

```{r, echo = FALSE}
ggplot(monthly_summary, aes(x = factor(month_name, levels = months_pl), 
                            y = total_revenue / 1e6, group = 1)) +
  geom_line(color = "darkgreen", size = 1.2) +
  geom_point(color = "darkgreen", size = 3) +
  scale_y_continuous(
    labels = scales::label_number(suffix = " mln", big.mark = " ", accuracy = 0.1)
  ) +
  labs(
    title = "Przychód z wypraw w poszczególnych miesiącach",
    x = "Miesiąc",
    y = "Przychód [mln USD]"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)  # lepsza czytelność nazw miesięcy
  )

```

Najwyższy miesięczny przychód odnotowano w miesiącu `r monthly_summary$month_name[which.max(monthly_summary$total_revenue)]`, 
osiągając wartość  `r scales::comma(max(monthly_summary$total_revenue, na.rm = TRUE), scale = 1/1e6, suffix = " mln")` USD.
Najniższy przychód przypadł na miesiąc `r monthly_summary$month_name[which.min(monthly_summary$total_revenue)]`, wynosząc `r scales::comma(min(monthly_summary$total_revenue, na.rm = TRUE), scale = 1/1e6, suffix = " mln")` USD.
To również może wskazywać na sezonowość przychodów.
```{r, echo = FALSE}
# Upewnij się, że masz kolumnę z nazwami miesięcy i ich numerami
months_pl <- c("styczeń", "luty", "marzec", "kwiecień", "maj", "czerwiec", 
               "lipiec", "sierpień", "wrzesień", "październik", "listopad", "grudzień")

monthly_status <- monthly_summary %>%
  mutate(month_name = months_pl[month_num]) %>%  # dodaj pełne nazwy miesięcy
  select(month_num, month_name, completed, delayed, cancelled) %>%
  pivot_longer(cols = c(completed, delayed, cancelled),
               names_to = "status", values_to = "count")

# Wykres
ggplot(monthly_status, aes(x = factor(month_name, levels = months_pl), 
                           y = count, fill = status)) +
  geom_col(position = "dodge") +
  labs(
    title = "Statusy wypraw w poszczególnych miesiącach",
    x = "Miesiąc",
    y = "Liczba wypraw",
    fill = "Status"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

```

Najwięcej zakończonych wypraw (`Completed`) odnotowano w miesiącu 
`r monthly_status %>% filter(status == "completed") %>% slice_max(count) %>% pull(month_name)`, 
z liczbą `r monthly_status %>% filter(status == "completed") %>% summarise(max(count)) %>% pull()` wypraw. 
Największa liczba opóźnionych wypraw (`Delayed`) wystąpiła w miesiącu 
`r monthly_status %>% filter(status == "delayed") %>% slice_max(count) %>% pull(month_name)`, 
osiągając `r monthly_status %>% filter(status == "delayed") %>% summarise(max(count)) %>% pull()` przypadków.
W przypadku anulowanych wypraw (`Cancelled`) szczyt przypadł na miesiąc 
`r monthly_status %>% filter(status == "cancelled") %>% slice_max(count) %>% pull(month_name)`, 
gdzie naliczono 
`r monthly_status %>% filter(status == "cancelled") %>% summarise(max(count)) %>% pull()` przypadków.

```{r, echo = FALSE}
ggplot(quarterly_summary, aes(x = factor(quarter), y = total_trips, fill = factor(quarter))) +
  geom_col(show.legend = FALSE) +
  labs(title = "Liczba wypraw kwartalnie",
       x = "Kwartał",
       y = "Liczba wypraw") +
  theme_minimal()
```
Największą liczbę wypraw zorganizowano w kwartale
`r quarterly_summary %>% slice_max(total_trips) %>% pull(quarter)`,
osiągając wynik
`r quarterly_summary %>% summarise(max(total_trips)) %>% pull()`
wypraw. Z kolei najmniejszą liczbę wypraw zrealizowano w kwartale
`r quarterly_summary %>% slice_min(total_trips) %>% pull(quarter)`,
zaledwie
`r quarterly_summary %>% summarise(min(total_trips)) %>% pull()`
wypraw.

```{r, echo = FALSE}
ggplot(quarterly_summary, aes(x = factor(quarter), y = total_revenue/1e6, fill = factor(quarter))) +
  geom_col(show.legend = FALSE) +
  scale_y_continuous(labels = scales::comma) +
  labs(title = "Przychód z wypraw kwartalnie",
       x = "Kwartał",
       y = "Przychód [mln USD]") +
  theme_minimal()
```

W tych samych okresach zauważalna jest również wyraźna zmienność
przychodów.Najwyższy przychód firma osiągnęła w kwartale
`r quarterly_summary %>% slice_max(total_revenue) %>% pull(quarter)`,
generując
`r scales::comma(quarterly_summary %>% summarise(max(total_revenue)) %>% pull())` USD.
Natomiast najniższy przychód zanotowano w kwartale
`r quarterly_summary %>% slice_min(total_revenue) %>% pull(quarter)`, z
wartością
`r scales::comma(quarterly_summary %>% summarise(min(total_revenue)) %>% pull())` USD.

```{r, echo = FALSE}
quarterly_status <- quarterly_summary %>%
  select(quarter, completed, delayed, cancelled) %>%
  tidyr::pivot_longer(cols = c(completed, delayed, cancelled),
                      names_to = "status", values_to = "count")

ggplot(quarterly_status, aes(x = factor(quarter), y = count, fill = status)) +
  geom_col(position = "dodge") +
  labs(title = "Statusy wypraw kwartalnie",
       x = "Kwartał",
       y = "Liczba wypraw",
       fill = "Status") +
  theme_minimal()

cancelled_quarters <- quarterly_status %>%
  filter(status == "cancelled")

cancelled_quarter <- if (all(cancelled_quarters$count == 0)) {
  "brak anulowanych wypraw"
} else {
  cancelled_quarters %>%
    slice_max(count, n = 1) %>%
    pull(quarter)
}

```

Najwięcej zakończonych wypraw przypadło na kwartał
`r quarterly_status %>% filter(status == "completed") %>% slice_max(count) %>% pull(quarter)`,
z liczbą
`r quarterly_status %>% filter(status == "completed") %>% summarise(max(count)) %>% pull()`.
Największa liczba opóźnionych wypraw wystąpiła w kwartale
`r quarterly_status %>% filter(status == "delayed") %>% slice_max(count) %>% pull(quarter)`,
natomiast najwięcej anulowanych wypraw miało miejsce w kwartale - 
`r cancelled_quarter`.\
Takie dane pozwalają lepiej rozumieć problemy operacyjne oraz
cykliczność niepowodzeń w realizacji wypraw.

Ciekawostką jest, że nie odnotowano żadnych anulowanych wypraw w żadnym miesiącu, co świadczy o bardzo wysokim poziomie operacyjnej
niezawodności.

```{r, echo = FALSE}
dbDisconnect(con)
```

# Podsumowanie

W przeprowadzonej analizie wykorzystano relacyjną bazę danych firmy Space-U w celu pozyskania informacji o strukturze organizacyjnej, klientach oraz zasobach technicznych. Z pomocą języka SQL oraz pakietów R wykonano szereg zapytań i transformacji, umożliwiających ekstrakcję, agregację i wizualizację danych. 

Efektem prac jest zestaw wniosków opartych na rzeczywistych danych, takich jak liczebność i zróżnicowanie zatrudnienia, aktywność klientów oraz stan techniczny i wykorzystanie rakiet. Analiza ujawnia m.in. potencjalne obszary do optymalizacji procesów oraz kierunki rozwoju operacyjnego. 

Z punktu widzenia projektowania baz danych, raport potwierdza znaczenie poprawnej struktury schematu, spójnych typów danych i kluczy obcych dla zapewnienia integralności oraz wydajności zapytań. Proces analityczny pokazał również, że odpowiednia integracja narzędzi programistycznych (R + SQL) umożliwia szybkie i skalowalne uzyskiwanie informacji biznesowych na podstawie dużych wolumenów danych.
